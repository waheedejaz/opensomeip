@startuml Core Class Diagram

title SOME/IP Core Classes

class Message {
    +MessageId messageId
    +uint32_t length
    +RequestId requestId
    +uint8_t protocolVersion
    +uint8_t interfaceVersion
    +MessageType messageType
    +ReturnCode returnCode
    +std::vector<uint8_t> payload

    +serialize(): std::vector<uint8_t>
    +deserialize(data: std::vector<uint8_t>): bool
    +getServiceId(): uint16_t
    +getMethodId(): uint16_t
    +isRequest(): bool
    +isResponse(): bool
}

class MessageId {
    +uint16_t serviceId
    +uint16_t methodId

    +MessageId(serviceId: uint16_t, methodId: uint16_t)
    +getServiceId(): uint16_t
    +getMethodId(): uint16_t
    +toUint32(): uint32_t
}

class RequestId {
    +uint16_t clientId
    +uint16_t sessionId

    +RequestId(clientId: uint16_t, sessionId: uint16_t)
    +getClientId(): uint16_t
    +getSessionId(): uint16_t
    +toUint32(): uint32_t
}

enum MessageType {
    REQUEST = 0x00
    REQUEST_NO_RETURN = 0x01
    NOTIFICATION = 0x02
    REQUEST_ACK = 0x40
    RESPONSE = 0x80
    ERROR = 0x81
    RESPONSE_ACK = 0xC0
    ERROR_ACK = 0xC1
    TP_REQUEST = 0x20
    TP_REQUEST_NO_RETURN = 0x21
    TP_NOTIFICATION = 0x22
}

enum ReturnCode {
    E_OK = 0x00
    E_NOT_OK = 0x01
    E_UNKNOWN_SERVICE = 0x02
    E_UNKNOWN_METHOD = 0x03
    E_NOT_READY = 0x04
    E_NOT_REACHABLE = 0x05
    E_TIMEOUT = 0x06
    E_WRONG_PROTOCOL_VERSION = 0x07
    E_WRONG_INTERFACE_VERSION = 0x08
    E_MALFORMED_MESSAGE = 0x09
    E_WRONG_MESSAGE_TYPE = 0x0A
}

class Serializer {
    -std::vector<uint8_t> buffer
    -size_t position

    +Serializer()
    +serializeBool(value: bool): void
    +serializeUint8(value: uint8_t): void
    +serializeUint16(value: uint16_t): void
    +serializeUint32(value: uint32_t): void
    +serializeUint64(value: uint64_t): void
    +serializeInt8(value: int8_t): void
    +serializeInt16(value: int16_t): void
    +serializeInt32(value: int32_t): void
    +serializeInt64(value: int64_t): void
    +serializeFloat(value: float): void
    +serializeDouble(value: double): void
    +serializeString(value: std::string): void
    +serializeArray<T>(value: std::vector<T>): void
    +getBuffer(): std::vector<uint8_t>
}

class Deserializer {
    -std::vector<uint8_t> buffer
    -size_t position

    +Deserializer(data: std::vector<uint8_t>)
    +deserializeBool(): bool
    +deserializeUint8(): uint8_t
    +deserializeUint16(): uint16_t
    +deserializeUint32(): uint32_t
    +deserializeUint64(): uint64_t
    +deserializeInt8(): int8_t
    +deserializeInt16(): int16_t
    +deserializeInt32(): int32_t
    +deserializeInt64(): int64_t
    +deserializeFloat(): float
    +deserializeDouble(): double
    +deserializeString(): std::string
    +deserializeArray<T>(): std::vector<T>
    +getPosition(): size_t
}

class SessionManager {
    -std::unordered_map<uint16_t, Session> sessions
    -std::mutex sessionMutex
    -uint16_t nextSessionId

    +createSession(clientId: uint16_t): uint16_t
    +getSession(sessionId: uint16_t): Session*
    +removeSession(sessionId: uint16_t): void
    +validateSession(sessionId: uint16_t): bool
    +getNextSessionId(): uint16_t
}

class Session {
    +uint16_t sessionId
    +uint16_t clientId
    +std::chrono::steady_clock::time_point lastActivity
    +SessionState state

    +updateActivity(): void
    +isExpired(timeout: std::chrono::seconds): bool
    +getState(): SessionState
    +setState(state: SessionState): void
}

enum SessionState {
    ACTIVE
    INACTIVE
    EXPIRED
    ERROR
}

' Relationships
Message *-- MessageId : contains
Message *-- RequestId : contains
Message *-- MessageType : uses
Message *-- ReturnCode : uses

SessionManager *-- Session : manages
Session *-- SessionState : has

@enduml
